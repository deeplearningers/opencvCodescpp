/****************************求2001的2003次方除以13的余数***********************/

#include<stdio.h>
#include<math.h>
#include<iostream>
#define Max 10000
using namespace std;
void function(int x, int num, int m)
{
	int i, r, a[Max];
	for (i = 1; i<=num; i++)
	{
		r = (int)(pow(x, i)) % m;
		a[i] = r;
		if (r==1)
		{
			break;
		}
		printf(" a[i]  r   i %d %d %d\n", a[i],r,i);
	}
	cout << x << "的" << num << "次幂" << "除以" << m << "余数是" << a[num % i] << endl;
}
int main()
{
	int x=0;int num=0, m=0;
	cout<<"请输入x的num次幂,除数m：";
	cin>> x>>num>>m;
	function(x, num, m);
	return 0;
}


//********************************此方法仅用来总结规律不用于计算************
//不用计算两个数的乘积，可以转化位分别求出1992÷7和59÷7的余数的积，使计算简单化。
//第一个余数是4，第二个余数是3.余数的乘积是12，除以7后的余数是5，所以1992×59除以7的余数是5.
//简单记做因为1992×59≡4×3≡5（mod7）,所以余数是5.

//void lj(int x, int num, int m)
//{
//	int i = 0;
//	int r = 0;
//	int a[Max];
//	while (i<6)  //i限制为6主要是因为幂指数过大会有内存溢出，次lj函数只是为了找规律
//	{
//		r = (int)(pow(x, i + 1)) % m;
//		printf("%d的%d次幂对%d取余数为：%d\n", x, (i + 1), m, r);
//		a[i] = r;
//		i++;
//	}
//}

/*
测试结果：
请输入x的num次幂：16 200（用16的200次幂对21求余数）
请输入模：21
a[0]:	16的1次幂对21取余数为：16
a[1]:	16的2次幂对21取余数为：4	16的2次幂对21取余数等于16的1次幂对21取余数（16）*16的1次幂对21取余数（16） = 16*16 % 21 = 256 % 21 = 4
a[2]:	16的3次幂对21取余数为：1	16的3次幂对21取余数等于16的2次幂对21取余数（16）*16的1次幂对21取余数（16） = 4*16 % 21 = 64 % 21 = 1
a[3]:	16的4次幂对21取余数为：16
a[4]:	16的5次幂对21取余数为：4
a[5]:	16的6次幂对21取余数为：1
因此总结得出规律x的num次幂对m取余数可以先找出前n个，然后用 num % n 求出的余数即代表第几个余数
*/

//****************************************************************************


